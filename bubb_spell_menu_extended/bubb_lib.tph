
	DEFINE_ACTION_FUNCTION B3_BAM_V2_RETURN_REFERENCED_PVRZ
		STR_VAR
			source_folder = ~~
			bam_files = ~~
		RET_ARRAY
			pvrz_references
	BEGIN
		ACTION_DEFINE_ARRAY pvrz_references BEGIN END
		LAF B3_RETURN_SPACE_ARRAY STR_VAR string = EVAL ~%bam_files%~ RET_ARRAY bam_files_array = space_array END
		ACTION_PHP_EACH bam_files_array AS i => bam_file BEGIN
			COPY ~%source_folder%\%bam_file%~ ~override~
				READ_ASCII 0x0000 signature (4)
				PATCH_IF ~%signature%~ STRING_EQUAL ~BAM ~ BEGIN
					READ_ASCII 0x0004 version (4)
					PATCH_IF ~%version%~ STRING_EQUAL ~V2  ~ BEGIN
						READ_LONG 0x0008 count_frame_entries
						READ_LONG 0x0014 offset_frame_entries
						READ_LONG 0x001c offset_data_blocks
						SET current_frame_entry_offset = offset_frame_entries
						FOR (i = 0 ; i < count_frame_entries ; ++i) BEGIN
							READ_SHORT current_frame_entry_offset + 0x0008 frame_start_offset_data_block
							SET current_data_block_offset = offset_data_blocks + (frame_start_offset_data_block) * (0x0018 + 4)
							READ_LONG current_data_block_offset + 0x0000 pvrz_page
							SET $pvrz_references(~%pvrz_page%~) = 1
							SET current_frame_entry_offset = current_frame_entry_offset + 0x000a + 2
						END
					END ELSE BEGIN
						//PATCH_PRINT ~Error: The version of %SOURCE_FILE% is invalid; aborting processing of %SOURCE_FILE%~
					END
				END ELSE BEGIN
					//PATCH_PRINT ~Error: The signature of %SOURCE_FILE% is invalid; aborting processing of %SOURCE_FILE%~
				END
			BUT_ONLY_IF_IT_CHANGES
		END
	END
	
	DEFINE_ACTION_FUNCTION B3_BAM_V2_INSTALL
		STR_VAR
			source_folder = ~~
			bam_files = ~~
	BEGIN
		LAF B3_BAM_V2_RETURN_REFERENCED_PVRZ STR_VAR source_folder = EVAL ~%source_folder%~ bam_files = EVAL ~%bam_files%~ RET_ARRAY pvrz_references END
		OUTER_SET free_index_search_start = 0
		ACTION_PHP_EACH pvrz_references AS pvrz_file => v BEGIN
			LAF B3_PAD_ZEROS INT_VAR number = pvrz_file desired_length = 4 RET padded_pvrz_file = padded_string END
			OUTER_SPRINT padded_pvrz_file ~MOS%padded_pvrz_file%.PVRZ~
			LAF FIND_FREE_PVRZ_INDEX INT_VAR start_index = free_index_search_start RET free_index END
			LAF B3_PAD_ZEROS INT_VAR number = free_index desired_length = 4 RET padded_free_index = padded_string END
			OUTER_SPRINT padded_free_index ~MOS%padded_free_index%.PVRZ~
			COPY ~%source_folder%\%padded_pvrz_file%~ ~override\%padded_free_index%~
			OUTER_SET $pvrz_references(~%pvrz_file%~) = free_index
			OUTER_SET free_index_search_start = free_index + 1
		END
		LAF B3_RETURN_SPACE_ARRAY STR_VAR string = EVAL ~%bam_files%~ RET_ARRAY bam_files_array = space_array END
		ACTION_PHP_EACH bam_files_array AS i => bam_file BEGIN
			COPY ~%source_folder%\%bam_file%~ ~override~
				READ_ASCII 0x0000 signature (4)
				PATCH_IF ~%signature%~ STRING_EQUAL ~BAM ~ BEGIN
					READ_ASCII 0x0004 version (4)
					PATCH_IF ~%version%~ STRING_EQUAL ~V2  ~ BEGIN
						READ_LONG 0x0008 count_frame_entries
						READ_LONG 0x0014 offset_frame_entries
						READ_LONG 0x001c offset_data_blocks
						SET current_frame_entry_offset = offset_frame_entries
						FOR (i = 0 ; i < count_frame_entries ; ++i) BEGIN
							READ_SHORT current_frame_entry_offset + 0x0008 frame_start_offset_data_block
							SET current_data_block_offset = offset_data_blocks + (frame_start_offset_data_block) * (0x0018 + 4)
							READ_LONG current_data_block_offset + 0x0000 pvrz_page
							WRITE_LONG current_data_block_offset + 0x0000 $pvrz_references(~%pvrz_page%~)
							SET current_frame_entry_offset = current_frame_entry_offset + 0x000a + 2
						END
					END ELSE BEGIN
						//PATCH_PRINT ~Error: The version of %SOURCE_FILE% is invalid; aborting processing of %SOURCE_FILE%~
					END
				END ELSE BEGIN
					//PATCH_PRINT ~Error: The signature of %SOURCE_FILE% is invalid; aborting processing of %SOURCE_FILE%~
				END
			BUT_ONLY_IF_IT_CHANGES
		END
	END
	
	DEFINE_ACTION_FUNCTION B3_RETURN_SPACE_ARRAY
		STR_VAR
			string = ~~
		RET_ARRAY
			space_array		
	BEGIN
		OUTER_PATCH ~%string%~ BEGIN
			SET insertion_index = 0
			SET string_length = STRING_LENGTH ~%string%~
			SET last_space_index = (0 - 1)
			FOR (i = 0; i < string_length; ++i) BEGIN
				READ_ASCII i read_char (1)
				PATCH_IF ~%read_char%~ STRING_EQUAL ~ ~ BEGIN
					SET element_length = i - last_space_index - 1
					PATCH_IF element_length > 0 BEGIN
						READ_ASCII last_space_index + 1 element (element_length)
						SPRINT $space_array(~%insertion_index%~) ~%element%~
						SET ++insertion_index
					END
					SET last_space_index = i
				END
			END
			SET element_length = string_length - last_space_index - 1
			PATCH_IF element_length > 0 BEGIN
				READ_ASCII last_space_index + 1 element (element_length)
				SPRINT $space_array(~%insertion_index%~) ~%element%~
			END
		END
	END

	DEFINE_ACTION_FUNCTION B3_PAD_ZEROS
		INT_VAR
			number = 0
			desired_length = 0
		RET
			padded_string
	BEGIN
		OUTER_SPRINT padded_string ~%number%~
		OUTER_SET zeros_needed = desired_length - STRING_LENGTH ~%padded_string%~
		OUTER_FOR (i = 0 ; i < zeros_needed ; ++i) BEGIN
			OUTER_SPRINT padded_string ~0%padded_string%~
		END
	END
	
	DEFINE_ACTION_FUNCTION B3_COPY_UIPATCH
	STR_VAR
		uipatch = ~~
	BEGIN
		OUTER_SPRINT uipatch_file ~%environment_directory%\uipatches\%uipatch%.uipatch~
		ACTION_IF FILE_EXISTS ~%uipatch_file%~ BEGIN
			COPY ~%uipatch_file%~ ~bubb_spell_menu_extended\work~
		END ELSE BEGIN
			FAIL ~UI patch file not present (%uipatch%). This is an installer error, please report to @Bubb on the Beamdog forums.~
		END
	END

	/**
	 * Patch function. Converts any decimal number into a hexadecimal number.
	 * INT_VAR value      The decimal number to convert.
	 * INT_VAR minDigits  Minimum number of digits for the returned hex value. (default: 1)
	 * INT_VAR prefix     A flag that indicates whether the returned number will be prefixed with "0x". (default: 0)
	 * RET hexNumber      The converted hexadecimal number as string.
	 */
	DEFINE_PATCH_FUNCTION TO_HEX_NUMBER
	INT_VAR
	  value     = 0
	  minDigits = 1
	  prefix    = 0
	RET
	  hexNumber
	BEGIN
	  SET minDigits = (minDigits < 1) ? 1 : minDigits
	  SET minDigits = (minDigits > 8) ? 8 : minDigits
	  TEXT_SPRINT hexNumber ~~
	  PATCH_DEFINE_ARRAY digit BEGIN ~0~ ~1~ ~2~ ~3~ ~4~ ~5~ ~6~ ~7~ ~8~ ~9~ ~a~ ~b~ ~c~ ~d~ ~e~ ~f~ END

	  PATCH_IF (value < 0) BEGIN
		SET signed = 1
		SET value = 0 - value
	  END ELSE BEGIN
		SET signed = 0
	  END

	  WHILE (value != 0) BEGIN
		SET curDigit = value BAND 0xf
		SET value = value BLSR 4
		TEXT_SPRINT hexDigit $EVAL digit(~%curDigit%~)
		TEXT_SPRINT hexNumber ~%hexDigit%%hexNumber%~
	  END

	  WHILE (STRING_LENGTH ~%hexNumber%~ < minDigits) BEGIN
		TEXT_SPRINT hexNumber ~0%hexNumber%~
	  END

	  PATCH_IF (prefix) BEGIN
		TEXT_SPRINT hexNumber ~0x%hexNumber%~
	  END

	  PATCH_IF (signed) BEGIN
		TEXT_SPRINT hexNumber ~-%hexNumber%~
	  END
	END

	// Action version of TO_HEX_NUMBER
	DEFINE_ACTION_FUNCTION TO_HEX_NUMBER
	INT_VAR
	  value     = 0
	  minDigits = 1
	  prefix    = 0
	RET
	  hexNumber
	BEGIN
	  OUTER_PATCH ~~ BEGIN
		LPF TO_HEX_NUMBER INT_VAR value = value minDigits = minDigits prefix = prefix RET hexNumber END
	  END
	END

	/**
	 * Patch function. Checks if an array key exists, and returns the value associated with said key. 
	 * INT_VAR key         The key to check for.
	 * STR_VAR array_name  The name of the array to check.
	 * RET result          1 if array contains key, 0 if array doesn't contain key.
	 */
	DEFINE_PATCH_FUNCTION ARRAY_GET_VALUE
	INT_VAR
		key = 0
	STR_VAR
		array_name = ~~
	RET
		exists
		value
	BEGIN
		PATCH_IF VARIABLE_IS_SET $~%array_name%~(~%key%~) BEGIN
			exists = 1
			PATCH_IF IS_AN_INT $~%array_name%~(~%key%~) BEGIN
				SET value = $~%array_name%~(~%key%~)
			END ELSE BEGIN
				TEXT_SPRINT value $~%array_name%~(~%key%~)
			END
		END ELSE BEGIN
			exists = 0
			value = 0
		END
	END
	
	// Action version of ARRAY_GET_VALUE
	DEFINE_ACTION_FUNCTION ARRAY_GET_VALUE
	INT_VAR
		key   = 0
	STR_VAR
		array_name = ~~
	RET
		exists
		value
	BEGIN
		OUTER_PATCH ~~ BEGIN
			LPF ARRAY_GET_VALUE INT_VAR key = key STR_VAR array_name = EVAL ~%array_name%~ RET exists value END
		END
	END
	
	// These are probably a better way to do STRING_REPLACE, but the old way works, so use them for now.
	/*// STRING_REPLACE
	DEFINE_PATCH_FUNCTION STRING_REPLACE
		STR_VAR
			string = ~~
			to_replace = ~~
			with = ~~
		RET
			replaced_string
	BEGIN
		INNER_PATCH ~%string%~ BEGIN
			REPLACE_TEXTUALLY ~%to_replace%~ ~%with%~
			READ_ASCII 0 replaced_string (BUFFER_LENGTH)
		END
	END
	
	// Action version of STRING_REPLACE
	DEFINE_ACTION_FUNCTION STRING_REPLACE
		STR_VAR
			string = ~~
			to_replace = ~~
			with = ~~
		RET
			replaced_string
	BEGIN
		OUTER_PATCH ~%string%~ BEGIN
			REPLACE_TEXTUALLY ~%to_replace%~ ~%with%~
			READ_ASCII 0 replaced_string (BUFFER_LENGTH)
		END
	END*/
	
	// STRING_REPLACE
	DEFINE_PATCH_FUNCTION STRING_REPLACE
	STR_VAR
		string = ~~
		to_replace = ~~
		with = ~~
	RET
		replaced_string
	BEGIN

		TEXT_SPRINT replaced_string ~~
		SET to_replace_length = STRING_LENGTH ~%to_replace%~
		SET last_found_index = (0 - to_replace_length)
		SET found_index = INDEX (EXACT_MATCH ~%to_replace%~ ~%string%~)
		
		WHILE (found_index != (0 - 1)) BEGIN
		
			PATCH_IF (found_index > 0) BEGIN
			
				SET before_substring_start = last_found_index + to_replace_length
				SET before_substring_length = found_index - last_found_index - to_replace_length
				LPF SUBSTRING INT_VAR start = before_substring_start length = before_substring_length STR_VAR string = EVAL ~%string%~ RET before_substring = substring END
				TEXT_SPRINT replaced_string ~%replaced_string%%before_substring%~
			END
		
			TEXT_SPRINT replaced_string ~%replaced_string%%with%~
			SET last_found_index = found_index
			SET found_index = INDEX (EXACT_MATCH ~%to_replace%~ ~%string%~ found_index + 1)
		END
	
		SET string_length = STRING_LENGTH ~%string%~
		SET after_substring_start = last_found_index + to_replace_length
		SET after_substring_length = string_length - last_found_index - to_replace_length
		LPF SUBSTRING INT_VAR start = after_substring_start length = after_substring_length STR_VAR string = EVAL ~%string%~ RET after_substring = substring END
		TEXT_SPRINT replaced_string ~%replaced_string%%after_substring%~
	END
	
	// Action version of STRING_REPLACE
	DEFINE_ACTION_FUNCTION STRING_REPLACE
	STR_VAR
		string = ~~
		to_replace = ~~
		with = ~~
	RET
		replaced_string
	BEGIN
		OUTER_PATCH ~~ BEGIN
			LPF STRING_REPLACE STR_VAR string = EVAL ~%string%~ to_replace = EVAL ~%to_replace%~ with = EVAL ~%with%~ RET replaced_string END
		END
	END
	
	DEFINE_ACTION_FUNCTION PROMPT_USER
	STR_VAR
		to_prompt = ~~
		accepted_responses = ~~
	RET
		response
	BEGIN
		PRINT ~%to_prompt%~
		ACTION_READLN response
		ACTION_IF NOT VARIABLE_IS_SET $~%accepted_responses%~(~%response%~) BEGIN
			LAF PROMPT_USER STR_VAR to_prompt = EVAL ~%to_prompt%~ accepted_responses = EVAL ~%accepted_responses%~ RET response END
		END
	END
	